<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="gzip.js"></script>
</head>
<body>
    <p>This thing reduces the size of sb3 files by deleting image and sound files (&approx; it corrupts the sb3 file). This is useful only in a few cases</p>
    <p><div>/!\ The output can't be opened in the offline editor /!\</div>
    <div>/!\ Expect permanent question marks if the assets weren't uploaded separately /!\</div></p>
    <div><label><input type="radio" name="mode" value="deleteAll"/> Delete all image and sound files</label></div>
    <div><label><input type="radio" name="mode" value="keepSome" checked id="modeChooser"/> Copy files until the size reaches the given size, delete all other files</label></div>
    <div><label>Target size: <input type="text" value="10" id="size"/>&nbsp;MiB</label></div>
    <div><label>Decompress files where compressed size is bigger than 0%&nbsp;<input type="range" min="0" max="100" value="100" id="maxCompressionBadness"/>&nbsp;100% of the original size</label></div>
    <input type="file" id="f"/>
    <button type="button" id="b">Start</button>
    <progress id="p" hidden></progress>
    <a id="a"></a>
    <div id="log"></div>
    <script>
/** @type {HTMLAnchorElement} */
var a = document.getElementById("a");
/** @type {HTMLButtonElement} */
var b = document.getElementById("b");
/** @type {HTMLInputElement} */
var fi = document.getElementById("f");
/** @type {HTMLProgressElement} */
var p = document.getElementById("p");
/** @type {HTMLInputElement} */
var modeChooser = document.getElementById("modeChooser");
/** @type {HTMLInputElement} */
var sizeInput = document.getElementById("size");
/** @type {HTMLInputElement} */
var maxCompressionBadness = document.getElementById("maxCompressionBadness");

var log=document.getElementById("log");

b.onclick = gomb;
async function gomb() {
    try {
        b.disabled = true;p.hidden=false;
        a.removeAttribute("href");
        a.innerText=log.innerText="";
        f = fi.files[0];
        a.href=URL.createObjectURL(await teszt(f));
        a.download="teszt.zip";
        a.innerText="Download processed copy";
    } catch(err) {
        console.error(err);
        alert(err);
    }
    b.disabled = false;p.hidden=true;
}
/**
 * @param {Blob} f 
 */
async function teszt(f) {
    var sizeLimit = (+sizeInput.value)*1024*1024;
    function say(msg) {
        var div=document.createElement("div");
        div.innerText=msg;
        log.appendChild(div);
    }
    var zip = new Zip(f);
    say("loadMetadata");
    await zip.loadMetadata(p);

    function getInfoForFile(filename) {
        let compSize = zip.getCompressedFileSize(filename);
        let realSize = zip.getFileSize(filename);
        let shouldDecompress = +maxCompressionBadness.value/100 < compSize/realSize;
        return {name: filename, shouldDecompress, outSize: shouldDecompress?realSize:compSize, realSize, compSize};
    }

    let filesToAdd = [getInfoForFile("project.json")];
    let size = 100+zip.getCompressedFileSize("project.json")+200;
    let smallest = null;
    if(modeChooser.checked) {
        say("picking some files to copy");
        let project = JSON.parse(new TextDecoder().decode(await zip.getFileContentAsync("project.json")));
        var assets=new Set();
        for(let target of project.targets) {
            for(let costume of target.costumes) {
                assets.add(costume.md5ext || `${costume.assetId}.${costume.dataFormat}`);
            }
            for(let sound of target.sounds) {
                assets.add(sound.md5ext || `${sound.assetId}.${sound.dataFormat}`);
            }
        }
        project = null;
        let list = zip.listDirectoryContent("").filter(x=>x!="project.json"&&assets.has(x));
        list = list.map(getInfoForFile);
        list.sort((a,b)=>b.outSize-a.outSize);
        while(list.length>0 && size+list[list.length-1].outSize+200<sizeLimit) {
            size+=list[list.length-1].outSize+150;
            filesToAdd.push(list.pop());
        }
        if(list.length>0) smallest=list[list.length-1];
    }
    say(`copying ${filesToAdd.length} files, ${zip.listDirectoryContent("").length-filesToAdd.length} left out`+(smallest!==null?` (the smallest left out is ${smallest.compSize/1024} KiB / ${smallest.realSize/1024} KiB)`:""));
    
    var filesToCopy = filesToAdd.filter(file=>!file.shouldDecompress).map(file=>file.name);
    var filesToDecompress = filesToAdd.filter(file=>file.shouldDecompress).map(file=>file.name);

    say(`copying ${filesToCopy.length} files without decompressing`);

    var zipout = new ZipMaker();
    await zipout.copyFiles(zip, filesToCopy, p);
    
    say(`decompressing ${filesToDecompress.length} files`);
    p.max=filesToDecompress.length;
    for(let i=0; i<filesToDecompress.length; i++) {
        p.value=i;
        await zipout.addFile(new Blob([await zip.getFileContentAsync(filesToDecompress[i])]), filesToDecompress[i]);
    }

    say("generateZip");
    var blob=await zipout.generateZip();
    say(`size: ${blob.size/1024/1024} MiB`);
    return blob;
}
    </script>
</body>
</html>